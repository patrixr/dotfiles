{"id":"919c7eb1-1c2f-47d6-8678-bf62b26474ff","zed":"context","version":"0.4.0","text":"\n\n\n```ts back-end/src/models_hk/auto-investment/auto-investment-calculation.ts\nimport {\n  AutoInvestmentOrderRequest,\n  GetAutoInvestmentOrderRequestInput,\n  GetAutoInvestmentOrderRequestPayload,\n  GetModelPortfoliosPayload,\n  GetTargetAmountInput,\n  GetTargetAmountPayload,\n  GetTimeHorizonInput,\n  GetTimeHorizonPayload,\n  GetTimeLineInput,\n  GetTimeLinePayload,\n  Holding,\n  ModelPortfolio,\n  Quote,\n} from '@models_hk/_schema';\nimport { Shared, SharedModel } from '@models_hk/_shared/_shared-models';\nimport { sumBy } from '@models_hk/_shared/utils';\nimport { MarketPriceModel } from '@models_hk/market-price/market-price';\nimport { simulatePortfolioReturns } from '@models_hk/market-price/monte-carlo';\nimport { QuoteModel } from '@models_hk/quote/quote';\nimport { TransactionModel } from '@models_hk/transaction/transaction';\nimport { CustomError } from '@storage/error-handling';\nimport { Logger } from '@storage/logger';\nimport { IStorage, IViewer } from '@typings/i-typings';\nimport BigNumber from 'bignumber.js';\nimport _ from 'lodash';\nimport { DateTime, Duration } from 'luxon';\nimport { quantileSeq, transpose } from 'mathjs';\nimport regression from 'regression';\n\nimport {\n  getHoldingsFromTransactions,\n  getNewHoldingsFromOrders,\n  populateHoldingsWithPrices,\n} from './holdings';\nimport {\n  genAutoInvestmentOrderRequest,\n  getCombinations,\n  isCurrency,\n  populateQuantity,\n} from './utils';\n\nconst averagedDaysPerMonth = 30.4368499;\n\n/**\n * A model to handle customers' goal calculation.\n */\nexport class AutoInvestmentCalculationModel {\n  static RELATIVE_DRIFT_CHANGE = 0.2;\n\n  static ABSOLUTE_DRIFT_CHANGE = 0.05;\n\n  static CASH_BUFFER_PERCENT = 0.01;\n\n  static FRACTIONAL_QUANTITY_DECIMALS = 6;\n\n  static NON_FRACTIONAL_QUANTITY_DECIMALS = 0;\n\n  static AMOUNT_DECIMALS = 2;\n\n  static UPPER_CASH_THRESHOLD_PERCENT = 0.01;\n\n  static UPPER_CASH_THRESHOLD_AMOUNT = 10;\n\n  static LOWER_CASH_THRESHOLD_PERCENT = 0.0025;\n\n  constructor(\n    private storage: IStorage,\n    private marketPriceModel: MarketPriceModel,\n    private quotesModel: QuoteModel,\n    private sharedModel: SharedModel,\n    private transactionModel: TransactionModel,\n  ) {}\n\n  static nameKey(id: string): string {\n    return `Portfolios.${id}.Name`;\n  }\n\n  static descriptionKey(id: string): string {\n    return `Portfolios.${id}.Description`;\n  }\n\n  static shortDescriptionKey(id: string): string {\n    return `Portfolios.${id}.ShortDescription`;\n  }\n\n  /**\n   * Return data points for the timeline.\n   */\n  async getGoalTimeLine(input: GetTimeLineInput): Promise<GetTimeLinePayload> {\n    const {\n      lumpSumAmount,\n      recurringAmount,\n      portfolioId,\n      timeHorizonYears,\n      numberOfDataPoints,\n    } = input;\n    const percentiles = input.percentiles.split(',').map(Number);\n    const startingDate = DateTime.utc().startOf('day');\n\n    await this.checkGoalInput(\n      lumpSumAmount,\n      recurringAmount,\n      portfolioId,\n      startingDate,\n      null,\n      percentiles,\n      null,\n    );\n\n    // Calculate time span between now and the goal\n    const timeSpan = Duration.fromObject({ years: timeHorizonYears });\n\n    // Create a list of dates at each data point for the x-axis\n    const dates = [];\n    let xAxisDate = DateTime.utc().startOf('day');\n    for (let i = 0; i < numberOfDataPoints; i++) {\n      dates.push(xAxisDate.toISO());\n      xAxisDate = xAxisDate.plus({\n        milliseconds: timeSpan.as('millisecond') / (numberOfDataPoints - 1),\n      });\n    }\n\n    // Calculate the amount invested per data point from monthly contribution\n    // rounding the timeSpan so that the total contribution matches expectations (e.g contrib*12*years)\n    const contributionPerYear = recurringAmount * 12;\n    const numberOfYears = Math.round(timeSpan.as('years'));\n    const totalContribution = contributionPerYear * numberOfYears;\n    const contributionPerHop = totalContribution / (numberOfDataPoints - 1);\n\n    // Calculate the total invested so far at each hop\n    const investedAmounts = [lumpSumAmount];\n    for (let i = 1; i < numberOfDataPoints; i++) {\n      investedAmounts[i] = investedAmounts[i - 1] + contributionPerHop;\n    }\n\n    // Get the monte-carlo simulated daily returns\n    const portfolio = await this.sharedModel.aiPortfolios.getModelPortfolioById(\n      portfolioId,\n    );\n    const stats = await this.marketPriceModel.getMonteCarloStatsHardcoded(\n      portfolio.holdings,\n    );\n    const percentileLines = simulatePortfolioReturns({\n      timeSpanYears: timeSpan.as('years'),\n      stats,\n      numberOfDataPoints,\n      percentileList: percentiles,\n      lumpSumAmount,\n      recurringAmount,\n    });\n\n    return {\n      dataPoints: {\n        dates,\n        investedAmounts,\n        percentileLines,\n      },\n    };\n  }\n\n  /**\n   * Return a target amount for the passed time horizon.\n   */\n  async getTargetAmount(\n    input: GetTargetAmountInput,\n  ): Promise<GetTargetAmountPayload> {\n    const timeHorizon = DateTime.fromISO(input.timeHorizon, { setZone: true });\n    const { lumpSumAmount, recurringAmount, portfolioId } = input;\n    const acceptancePercentile = input.acceptancePercentile || 50;\n    const initialStartingDate =\n      input.initialStartingDate &&\n      DateTime.fromISO(input.initialStartingDate, { setZone: true });\n    const startingDate = (initialStartingDate || DateTime.utc()).startOf('day');\n\n    await this.checkGoalInput(\n      lumpSumAmount,\n      recurringAmount,\n      portfolioId,\n      startingDate,\n      timeHorizon,\n    );\n\n    const numberOfDataPoints = 5;\n    const timeSpan = timeHorizon.startOf('day').diff(startingDate, ['days']);\n    // Calculate ticks\n    const ticks = this.getTicks(timeSpan, numberOfDataPoints);\n\n    const futureDailyReturnsPerPercentile = await this.getDailyReturns(\n      portfolioId,\n      ticks,\n      numberOfDataPoints,\n    );\n    if (!futureDailyReturnsPerPercentile) {\n      return null;\n    }\n\n    const addedContribution =\n      (recurringAmount * timeSpan.as('days')) /\n      (numberOfDataPoints - 1) /\n      averagedDaysPerMonth;\n\n    const futureMarketValuesPerSimulation = this.getFutureValues(\n      futureDailyReturnsPerPercentile,\n      lumpSumAmount,\n      addedContribution,\n    );\n\n    const transposedFutureMarketValues = transpose(\n      futureMarketValuesPerSimulation,\n    ) as number[][];\n\n    const dataPoints = transposedFutureMarketValues.map(\n      (g) => quantileSeq(g, acceptancePercentile / 100) as number[],\n    );\n\n    const xToPlot = Array.from(Array(dataPoints.length).keys()).map((pt) =>\n      Number(pt),\n    );\n\n    const inputData = xToPlot.map((x, index) => [x, dataPoints[index]]);\n    const polynomial = regression.polynomial(inputData, { order: 3 });\n    const yData = transpose(polynomial.points)[1];\n\n    return { targetAmount: Math.round(yData[yData.length - 1]) };\n  }\n\n  /**\n   * Return a target horizon for the passed target amount.\n   */\n  async getTimeHorizon(\n    input: GetTimeHorizonInput,\n  ): Promise<GetTimeHorizonPayload> {\n    const { targetAmount, lumpSumAmount, recurringAmount, portfolioId } = input;\n    const acceptancePercentile = input.acceptancePercentile || 50;\n    const initialStartingDate =\n      input.initialStartingDate &&\n      DateTime.fromISO(input.initialStartingDate, { setZone: true });\n    const startingDate = (initialStartingDate || DateTime.utc()).startOf('day');\n\n    await this.checkGoalInput(\n      lumpSumAmount,\n      recurringAmount,\n      portfolioId,\n      startingDate,\n      null,\n      null,\n      targetAmount,\n    );\n\n    const numberOfDataPoints = 13;\n    // The time span is about 1 year (the average days * 12 months).\n    const timeSpan = DateTime.utc()\n      .plus({ days: averagedDaysPerMonth * (numberOfDataPoints - 1) })\n      .diff(startingDate, ['days']);\n    const ticks = this.getTicks(timeSpan, numberOfDataPoints);\n\n    const futureDailyReturnsPerPercentile = await this.getDailyReturns(\n      portfolioId,\n      ticks,\n      numberOfDataPoints,\n    );\n    if (!futureDailyReturnsPerPercentile) {\n      return null;\n    }\n\n    let lastValue = lumpSumAmount;\n    const addedContribution =\n      (recurringAmount * timeSpan.as('days')) /\n      (numberOfDataPoints - 1) /\n      averagedDaysPerMonth;\n    const dataPoints = [lumpSumAmount];\n\n    // 60 means 5 years, so each loop means the calculation for 1 month.\n    for (let i = 0; i <= 4; i++) {\n      const futureMarketValuesPerSimulation = this.getFutureValues(\n        futureDailyReturnsPerPercentile,\n        lastValue,\n        addedContribution,\n      );\n\n      const transposedFutureMarketValues = transpose(\n        futureMarketValuesPerSimulation,\n      ) as number[][];\n\n      const percentiles = transposedFutureMarketValues.map(\n        (g) => quantileSeq(g, acceptancePercentile / 100) as number,\n      );\n\n      dataPoints.push(...percentiles.filter((_, index) => index !== 0));\n\n      const xToPlot = Array.from(Array(dataPoints.length).keys()).map((pt) =>\n        Number(pt),\n      );\n\n      const input = xToPlot.map((x, index) => [x, dataPoints[index]]);\n      const polynomial = regression.polynomial(input, { order: 3 });\n      const yData = transpose(polynomial.points)[1].map((v, i) =>\n        i !== 0 ? v : lumpSumAmount,\n      );\n\n      lastValue = yData[yData.length - 1];\n\n      if (lastValue > targetAmount) {\n        for (\n          let j = (i - 1) * (numberOfDataPoints - 1);\n          j < yData.length - 1;\n          j++\n        ) {\n          if (yData[j] >= targetAmount) {\n            return {\n              targetDate: startingDate\n                .plus({\n                  days: (timeSpan.days * j) / (numberOfDataPoints - 1),\n                })\n                .toISO(),\n            };\n          }\n        }\n      }\n    }\n\n    return null;\n  }\n\n  async getModelPortfolios(\n    viewer: IViewer,\n  ): Promise<GetModelPortfoliosPayload> {\n    const { minScore } = Shared.rpqConstants.getMaxMinScore();\n    const translationKeys = (\n      await this.sharedModel.aiPortfolios.getModelPortfolios()\n    ).flatMap((p) => [\n      AutoInvestmentCalculationModel.nameKey(p.id),\n      AutoInvestmentCalculationModel.descriptionKey(p.id),\n      AutoInvestmentCalculationModel.shortDescriptionKey(p.id),\n    ]);\n\n    // retrieve localized content\n    const translations =\n      await this.sharedModel.translationHelpers.getLocalizedContents(\n        translationKeys,\n        viewer.language,\n      );\n\n    const modelPortfolios = (\n      await this.sharedModel.aiPortfolios.getModelPortfolios()\n    ).map((p) => ({\n      ...p,\n      riskScore: p.id === 'sofi.conservative' ? minScore : p.riskScore,\n      assetClassAllocations: p.assetClassAllocations\n        .map((a) => ({\n          ...a,\n          allocationName: this.storage.translate.t(\n            `asset-classes.${a.allocationId}`,\n          ),\n        }))\n        .sort((a, b) => b.weight - a.weight),\n      holdings: p.holdings\n        .map((h) => ({\n          ...h,\n          allocationName: this.storage.translate.t(\n            `holdings.${h.allocationId}`,\n          ),\n          logoUrl: Shared.logoConstants.getLogo(\n            this.storage.config.marketDataLogoUrl,\n            h.allocationId,\n          ),\n        }))\n        .sort((a, b) => b.weight - a.weight),\n      geographicAllocations: p.geographicAllocations.sort(\n        (a, b) => b.weight - a.weight,\n      ),\n      sectorAllocations: p.sectorAllocations\n        .map((s) => ({\n          ...s,\n          allocationName: this.storage.translate.t(`sectors.${s.allocationId}`),\n        }))\n        .sort((a, b) => b.weight - a.weight),\n      name: translations[AutoInvestmentCalculationModel.nameKey(p.id)],\n      description:\n        translations[AutoInvestmentCalculationModel.descriptionKey(p.id)],\n      shortDescription:\n        translations[AutoInvestmentCalculationModel.shortDescriptionKey(p.id)],\n    }));\n\n    return {\n      modelPortfolios,\n    };\n  }\n\n  async getAutoInvestmentOrders(\n    viewer: IViewer,\n    input: GetAutoInvestmentOrderRequestInput,\n  ): Promise<GetAutoInvestmentOrderRequestPayload> {\n    const {\n      portfolioId,\n      contribution = 0,\n      accountId,\n      prices,\n      rebalancing,\n      isFractional,\n    } = input;\n\n    // Treats as the first order if the props doesn't have the account id.\n    const isFirstOrder = !accountId;\n\n    const portfolio = await this.sharedModel.aiPortfolios.getModelPortfolioById(\n      portfolioId,\n      { includeDeprecated: true },\n    );\n\n    if (!portfolio) {\n      throw new Error('portfolioId is invalid.');\n    }\n\n    // Get the user's transactions before getting all the quotes.\n    // Possible that the model portfolio will change, so the user may have\n    // symbols which are no longer in the model portfolio, thus we get them\n    // before fetching all the quotes.\n    const bosTransactions = isFirstOrder\n      ? []\n      : await this.transactionModel.getBosTransactions({\n          accounts: [{ id: accountId }],\n        });\n\n    const gtsTransactions = isFirstOrder\n      ? []\n      : await this.transactionModel.getGtsTransactions({\n          accountIds: [accountId],\n        });\n\n    const transactions = [\n      ...(bosTransactions[accountId] || []),\n      ...gtsTransactions,\n    ];\n\n    const currentHoldings = getHoldingsFromTransactions(\n      portfolio.currency,\n      transactions,\n    );\n\n    const stockHoldings = currentHoldings.filter((h) => {\n      return !isCurrency(h.symbol) && h.quantity > 0;\n    });\n\n    const currencyHolding = currentHoldings.find((h) => {\n      return h.symbol === portfolio.currency;\n    });\n    const cash = currencyHolding?.quantity || 0;\n\n    // The account has enough to make the -ve contribution already\n    // fake a cash out order to make explicit that no orders will be generated\n    if (\n      contribution < 0 &&\n      currencyHolding?.quantity >= Math.abs(contribution)\n    ) {\n      return {\n        orders: [\n          {\n            quantity: contribution,\n            unitPrice: 1,\n            totalPrice: contribution,\n            symbol: currencyHolding.symbol,\n          },\n        ],\n        remainingCash: new BigNumber(currencyHolding.quantity)\n          .minus(Math.abs(contribution))\n          .toNumber(),\n        newHoldings: stockHoldings,\n        oldHoldings: stockHoldings,\n      };\n    }\n\n    const uniqueSymbols = Array.from(\n      new Set([\n        ...portfolio.holdings.map((a) => a.allocationId),\n        ...stockHoldings\n          .filter((h) => !isCurrency(h.symbol))\n          .map((h) => h.symbol),\n      ]),\n    );\n\n    let quotes: Quote[];\n    if (!prices) {\n      quotes = await this.quotesModel.genQuotes(\n        viewer,\n        uniqueSymbols,\n        'delayed',\n      );\n    } else {\n      quotes = prices.map((p) => {\n        return {\n          symbol: p.symbol,\n          last: p.price,\n        };\n      });\n\n      const missingSymbols = uniqueSymbols.filter((symbol) => {\n        return !prices.find((p) => p.symbol === symbol);\n      });\n\n      if (missingSymbols.length) {\n        throw new CustomError(\n          `getAutoInvestmentOrders: No price for - ${missingSymbols.join(\n            ', ',\n          )}`,\n        );\n      }\n    }\n\n    if (quotes.some((q) => !q)) {\n      throw new CustomError('getAutoInvestmentOrders: No quotes', null, {\n        symbols: uniqueSymbols,\n        quotes,\n      });\n    }\n\n    // Current holdings\n    const idealWeights = await this.sharedModel.aiPortfolios.getIdealWeightsSet(\n      portfolioId,\n    );\n    const currentStockHoldingsWithPrice = populateHoldingsWithPrices(\n      stockHoldings,\n      quotes,\n      idealWeights,\n    );\n\n    if (input.sellAll) {\n      const orders: AutoInvestmentOrderRequest[] = currentStockHoldingsWithPrice\n        .map((h) => {\n          return {\n            orderSide: 'sell',\n            symbol: h.symbol,\n            quantity: h.quantity > 0 ? -h.quantity : 0,\n            unitPrice: h.unitPrice,\n            totalPrice: -h.marketValue,\n          };\n        })\n        .filter((o) => o.quantity < 0);\n\n      return {\n        orders,\n        remainingCash: currencyHolding?.quantity,\n        newHoldings: getNewHoldingsFromOrders(\n          currentStockHoldingsWithPrice,\n          orders,\n          quotes,\n          idealWeights,\n        ),\n        oldHoldings: currentStockHoldingsWithPrice,\n      };\n    }\n\n    // Executed orders in GTS means the \"order\" has been partially processed.\n    // This means the SELL orders have been executed, and the account now has\n    // cash to be reinvested into the account.\n    if (gtsTransactions.length) {\n      // This should never be called since for buy orders we run getAutoInvestmentBuyOrders()\n      Logger.info('getAutoInvestmentOrders: GTS transactions found');\n\n      const cashFlowOrders = this.getCashFlowRebalancingOrders(\n        portfolio,\n        cash,\n        currentStockHoldingsWithPrice,\n        quotes,\n        contribution,\n      );\n\n      const remainingCash = new BigNumber(cash)\n        .minus(sumBy(cashFlowOrders, 'totalPrice'))\n        .dp(\n          AutoInvestmentCalculationModel.AMOUNT_DECIMALS,\n          BigNumber.ROUND_DOWN,\n        )\n        .toNumber();\n\n      return {\n        orders: cashFlowOrders,\n        remainingCash,\n        newHoldings: getNewHoldingsFromOrders(\n          currentStockHoldingsWithPrice,\n          cashFlowOrders,\n          quotes,\n          idealWeights,\n        ),\n        oldHoldings: currentStockHoldingsWithPrice,\n      };\n    }\n\n    const currentStockHoldingsValue =\n      sumBy(\n        currentStockHoldingsWithPrice,\n        'marketValue',\n        AutoInvestmentCalculationModel.AMOUNT_DECIMALS,\n        0,\n      ) || 0;\n    const currentAccountValue = new BigNumber(currentStockHoldingsValue)\n      .plus(currencyHolding?.quantity || 0)\n      .toNumber();\n\n    // expected account value after orders being placed\n    const expectedAccountValue = new BigNumber(contribution)\n      .plus(currentAccountValue)\n      .dp(AutoInvestmentCalculationModel.AMOUNT_DECIMALS, BigNumber.ROUND_DOWN)\n      .toNumber();\n\n    // Get ideal holdings based on contribution to the account\n    // For rebalancing, the contribution should be 0\n    const idealHoldings = this.getIdealHoldings(\n      portfolio,\n      quotes,\n      expectedAccountValue,\n      isFractional,\n    );\n\n    // this if serves as a guard clause to prevent the account from being rebalanced\n    // if the conditions are not met, we return early with empty orders\n    // if we're not running the rebalancing process (rebalancing=false), we don't need to check the conditions\n    // we will rebalance anyway (i.e. generate both buy and sell orders)\n    if (rebalancing) {\n      const useAutoInvestRelativeThreshold =\n        await this.sharedModel.flags.isFeatureEnabled(\n          'useAutoInvestRelativeThreshold',\n          viewer,\n        );\n\n      // Calculate if some of the symbols have drifted in weight from the ideal\n      // holdings. Map through idealHoldings to cover the situation where the\n      // currentStockHoldings have a missing symbol or has no symbols to ensure that\n      // hasDrifted is true.\n      const hasDrifted = idealHoldings.some((idealHolding) => {\n        if (isCurrency(idealHolding.symbol)) {\n          return false;\n        }\n\n        const currentStockHolding = currentStockHoldingsWithPrice.find(\n          (h) => h.symbol === idealHolding.symbol,\n        );\n\n        // currentStockHoldings does not have one of the ideal holdings\n        if (!currentStockHolding) {\n          return true;\n        }\n\n        // Compare current Holding weight to idealHolding weight\n        const driftChange = new BigNumber(currentStockHolding.weight)\n          .minus(idealHolding.weight)\n          .abs();\n\n        const maxDriftChangePerHolding = useAutoInvestRelativeThreshold\n          ? new BigNumber(\n              AutoInvestmentCalculationModel.RELATIVE_DRIFT_CHANGE,\n            ).times(idealHolding.weight)\n          : new BigNumber(AutoInvestmentCalculationModel.ABSOLUTE_DRIFT_CHANGE);\n\n        return driftChange.gt(maxDriftChangePerHolding);\n      });\n\n      const symbolsToSell = currentStockHoldingsWithPrice.some(\n        (currentStockHolding) => {\n          const idealHolding = idealHoldings.find(\n            (h) => h.symbol === currentStockHolding.symbol,\n          );\n\n          return !idealHolding;\n        },\n      );\n\n      const symbolsToBuy = idealHoldings\n        .filter((h) => !isCurrency(h.symbol))\n        .some((idealHolding) => {\n          const currentStockHolding = currentStockHoldingsWithPrice.find(\n            (h) => h.symbol === idealHolding.symbol,\n          );\n\n          return !currentStockHolding;\n        });\n\n      const overCashThreshold =\n        cash >=\n        AutoInvestmentCalculationModel.UPPER_CASH_THRESHOLD_AMOUNT +\n          currentAccountValue *\n            AutoInvestmentCalculationModel.UPPER_CASH_THRESHOLD_PERCENT;\n      const underCashThreshold =\n        cash <\n        currentAccountValue *\n          AutoInvestmentCalculationModel.LOWER_CASH_THRESHOLD_PERCENT;\n\n      const hasHoldings = currentStockHoldingsWithPrice?.length > 0;\n\n      // Conditions to rebalance\n      // - Has some holdings (prevents cash only accounts being rebalanced)\n      // - Meets one of the rebalancing criteria:\n      //    - Has excess cash of $10 or more\n      //    - Has drifted\n      //    - Has missing symbols\n      //    - Has negative cash\n      const shouldRebalance =\n        (overCashThreshold ||\n          underCashThreshold ||\n          hasDrifted ||\n          symbolsToSell ||\n          symbolsToBuy) &&\n        hasHoldings;\n\n      if (!shouldRebalance) {\n        return {\n          orders: [],\n          remainingCash: cash,\n        };\n      }\n    }\n\n    // Calculates the rebalancing orders purely based on \"amount\"\n    // When rebalancing we are concerned with the \"weight\" of your holding\n    // which is based on the market value, so we calculate the initial set of\n    // rebalancing orders by amount\n    const idealRebalancingOrders = this.getIdealRebalancingOrders(\n      currentStockHoldingsWithPrice,\n      idealHoldings,\n    );\n\n    // Takes the rebalancing orders and populates the quantity based on each\n    // order's amount\n    let orders = populateQuantity(idealRebalancingOrders, isFractional);\n\n    // Checks again for any symbols which are in the current portfolio, but are\n    // not in the model portfolio. Since we cautiously calculate the quantities\n    // of the orders based on the amount, the quantities for these orders\n    // may not equal the actual quantity of the position.\n    const excessSymbols = currentStockHoldingsWithPrice.filter(\n      (currentStockHolding) => {\n        const idealHolding = idealHoldings.find(\n          (h) => h.symbol === currentStockHolding.symbol,\n        );\n\n        return !idealHolding;\n      },\n    );\n\n    // If there are excess symbols to sell, we can go through each one and\n    // hard-code the quantity/amount based on the position from the portfolio\n    // rather than trying to calculate the quantity.\n    if (excessSymbols.length) {\n      orders = orders.map((order) => {\n        const isExcessSymbol = excessSymbols.some(\n          (s) => s.symbol === order.symbol,\n        );\n        const currentHolding = currentStockHoldingsWithPrice.find(\n          (h) => h.symbol === order.symbol,\n        );\n\n        return {\n          ...order,\n          ...(isExcessSymbol &&\n            currentHolding && {\n              quantity: -currentHolding.quantity,\n              totalPrice: -currentHolding.marketValue,\n            }),\n        };\n      });\n    }\n\n    const newHoldings = getNewHoldingsFromOrders(\n      currentStockHoldingsWithPrice,\n      orders,\n      quotes,\n      idealWeights,\n    );\n\n    return {\n      orders,\n      remainingCash: idealHoldings.find((h) => isCurrency(h.symbol))?.quantity,\n      oldHoldings: currentStockHoldingsWithPrice,\n      newHoldings,\n    };\n  }\n\n  async getAutoInvestmentBuyOrders(\n    viewer: IViewer,\n    input: {\n      portfolioId: string;\n      accountId: string;\n      pendingWithdrawalAmount: number;\n    },\n  ): Promise<GetAutoInvestmentOrderRequestPayload> {\n    const { portfolioId, accountId, pendingWithdrawalAmount } = input;\n\n    const portfolio = await this.sharedModel.aiPortfolios.getModelPortfolioById(\n      portfolioId,\n      { includeDeprecated: true },\n    );\n\n    if (!portfolio) {\n      throw new Error('portfolioId is invalid.');\n    }\n\n    // Get the user's transactions before getting all the quotes.\n    // Possible that the model portfolio will change, so the user may have\n    // symbols which are no longer in the model portfolio, thus we get them\n    // before fetching all the quotes.\n    const bosTransactions = await this.transactionModel.getBosTransactions({\n      accounts: [{ id: accountId }],\n    });\n    const gtsTransactions = await this.transactionModel.getGtsTransactions({\n      accountIds: [accountId],\n    });\n    const transactions = [\n      ...(bosTransactions[accountId] || []),\n      ...gtsTransactions,\n    ];\n\n    const currentHoldings = getHoldingsFromTransactions(\n      portfolio.currency,\n      transactions,\n    );\n\n    const stockHoldings = currentHoldings.filter((h) => {\n      return !isCurrency(h.symbol);\n    });\n\n    const currencyHolding = currentHoldings.find((h) => {\n      return h.symbol === portfolio.currency;\n    });\n    const cash = new BigNumber(currencyHolding?.quantity || 0)\n      .minus(pendingWithdrawalAmount)\n      .toNumber();\n\n    const uniqueSymbols = Array.from(\n      new Set([\n        ...portfolio.holdings.map((a) => a.allocationId),\n        ...stockHoldings\n          .filter((h) => !isCurrency(h.symbol))\n          .map((h) => h.symbol),\n      ]),\n    );\n\n    const quotes = await this.quotesModel.genQuotes(\n      viewer,\n      uniqueSymbols,\n      'delayed',\n    );\n\n    if (quotes.some((q) => !q)) {\n      throw new CustomError('getAutoInvestmentOrders: No quotes', null, {\n        symbols: uniqueSymbols,\n        quotes,\n      });\n    }\n\n    // Current holdings\n    const currentStockHoldingsWithPrice = populateHoldingsWithPrices(\n      stockHoldings,\n      quotes,\n    );\n\n    if (cash <= 0) {\n      return {\n        orders: [],\n        remainingCash: cash,\n      };\n    }\n\n    const orders = this.getCashFlowRebalancingOrders(\n      portfolio,\n      cash,\n      currentStockHoldingsWithPrice,\n      quotes,\n    );\n\n    const remainingCash = new BigNumber(cash)\n      .minus(sumBy(orders, 'totalPrice'))\n      .dp(AutoInvestmentCalculationModel.AMOUNT_DECIMALS, BigNumber.ROUND_DOWN)\n      .toNumber();\n\n    return {\n      orders,\n      remainingCash,\n    };\n  }\n\n  /**\n   * Get ideal rebalanced holdings for creating an account.\n   */\n  private getIdealHoldings(\n    portfolio: ModelPortfolio,\n    quotes: Quote[],\n    accountValue: number,\n    isFractional?: boolean,\n  ): Holding[] {\n    const cashBufferAmount = new BigNumber(Math.max(0, accountValue))\n      .times(AutoInvestmentCalculationModel.CASH_BUFFER_PERCENT)\n      .dp(2, BigNumber.ROUND_HALF_UP);\n    const capacity = Number(\n      new BigNumber(accountValue).minus(cashBufferAmount),\n    );\n\n    const { idealHoldings, remainingCash: remainingCashTemp } =\n      this.getFlooredWeightedHoldings(\n        portfolio,\n        quotes,\n        accountValue,\n        capacity,\n        isFractional,\n      );\n\n    let remainingCash = remainingCashTemp;\n    // if round share orders, find the best combination of symbols to allocate the rest of the cash\n    if (!isFractional) {\n      const result = this.getBestCombination(quotes, remainingCashTemp);\n      remainingCash = result.remainingCash;\n\n      for (const holding of result.bestCombination) {\n        const index = idealHoldings.findIndex(\n          (h) => h.symbol === holding.symbol,\n        );\n\n        if (index >= 0) {\n          idealHoldings[index].quantity++;\n        } else {\n          idealHoldings.push({\n            symbol: holding.symbol,\n            quantity: 1,\n            unitPrice: holding.last,\n            marketValue: holding.last,\n          });\n        }\n      }\n    }\n\n    const idealHoldingsValue = sumBy(\n      idealHoldings,\n      'marketValue',\n      AutoInvestmentCalculationModel.AMOUNT_DECIMALS,\n      0,\n    );\n    const idealHoldingsWithWeight = idealHoldings.map((h) => ({\n      ...h,\n      weight: idealHoldingsValue\n        ? Number(new BigNumber(h.marketValue).div(idealHoldingsValue))\n        : 0,\n    }));\n\n    const currencySymbol = portfolio.currency;\n    const currencyQuantity = Number(\n      new BigNumber(remainingCash).plus(cashBufferAmount),\n    );\n\n    idealHoldingsWithWeight.push({\n      symbol: currencySymbol,\n      quantity: currencyQuantity,\n      weight: idealHoldingsValue\n        ? Number(new BigNumber(currencyQuantity).div(idealHoldingsValue))\n        : 0,\n    });\n\n    return idealHoldingsWithWeight;\n  }\n\n  /**\n   * Get the ideal rebalancing order\n   * Making right and left union to cater with the possibility of missing/new symbols\n   * ex: if we change an holding in a model portfolio,\n   * currentHoldings will have the old one, but not the new one\n   * idealHoldings will have the new one, but not the old one\n   */\n  private getIdealRebalancingOrders(\n    currentHoldings: Holding[],\n    idealHoldings: Holding[],\n  ): AutoInvestmentOrderRequest[] {\n    const leftOrders = idealHoldings.map((ih) => {\n      const holding = currentHoldings.find((ch) => ih.symbol === ch.symbol);\n      const totalPrice = new BigNumber(ih?.marketValue || 0)\n        .minus(holding?.marketValue || 0)\n        .toNumber();\n\n      return genAutoInvestmentOrderRequest(ih.symbol, ih.unitPrice, totalPrice);\n    });\n\n    const rightOrders = currentHoldings.map((ch) => {\n      const holding = idealHoldings.find((ih) => ih.symbol === ch.symbol);\n      const totalPrice = new BigNumber(-(ch?.marketValue || 0))\n        .plus(holding?.marketValue || 0)\n        .toNumber();\n\n      return genAutoInvestmentOrderRequest(ch.symbol, ch.unitPrice, totalPrice);\n    });\n\n    // Concat the left-order and the right-orders, and distinct by the symbol.\n    const orders = leftOrders.concat(\n      rightOrders.filter(\n        (ro) => !leftOrders.find((lo) => lo.symbol === ro.symbol),\n      ),\n    );\n\n    // filter out currency orders as it doesn't make sense to have any\n    return orders.filter((o) => !isCurrency(o.symbol));\n  }\n\n  // Get the\n  private getFlooredWeightedHoldings(\n    portfolio: ModelPortfolio,\n    quotes: Quote[],\n    accountValue: number,\n    capacity: number,\n    isFractional?: boolean,\n  ): { idealHoldings: Holding[]; remainingCash: number } {\n    let remainingCash = capacity;\n    const roundingDecimals = isFractional\n      ? AutoInvestmentCalculationModel.FRACTIONAL_QUANTITY_DECIMALS\n      : AutoInvestmentCalculationModel.NON_FRACTIONAL_QUANTITY_DECIMALS;\n\n    const idealHoldings = portfolio.holdings.reduce((acc, allocation) => {\n      const quote = quotes.find((p) => p?.symbol === allocation.allocationId);\n\n      const marketValue = quote\n        ? new BigNumber(accountValue)\n            .times(allocation.weight)\n            .dp(\n              AutoInvestmentCalculationModel.AMOUNT_DECIMALS,\n              BigNumber.ROUND_DOWN,\n            )\n            .toNumber()\n        : 0;\n\n      if (marketValue !== 0) {\n        remainingCash = new BigNumber(remainingCash)\n          .minus(marketValue)\n          .dp(\n            AutoInvestmentCalculationModel.AMOUNT_DECIMALS,\n            BigNumber.ROUND_DOWN,\n          )\n          .toNumber();\n\n        acc.push({\n          symbol: allocation.allocationId,\n          quantity: new BigNumber(marketValue)\n            .div(quote.last)\n            .dp(roundingDecimals, BigNumber.ROUND_DOWN)\n            .toNumber(),\n          unitPrice: quote.last,\n          marketValue,\n        });\n      }\n\n      return acc;\n    }, []);\n\n    return { idealHoldings, remainingCash };\n  }\n\n  /**\n   * knapsack problem: https://en.wikipedia.org/wiki/Knapsack_problem\n   * Handle how allocate the rest of money. Try making it least.\n   *  1. Sort prices by ascending.\n   *  2. Take the first N prices and sum them up.\n   *  3. Get all combinations of them.\n   *  4. Find the best combination.\n   * NOTE: This might note be needed if we use fractional share\n   */\n  private getBestCombination(\n    quotes: Quote[],\n    capacity: number,\n  ): { bestCombination: Quote[]; remainingCash: number } {\n    const orderedPrices = _.sortBy(quotes, 'last');\n    let bestSum = 0;\n    let bestCombination: Quote[] = [];\n\n    const maxNumOfKnapsackCombination =\n      orderedPrices.length >= 15 ? 15 : orderedPrices.length;\n\n    for (let k = 1; k < maxNumOfKnapsackCombination; k++) {\n      // Take the first k prices and sum them up\n      const firstKPrices = orderedPrices.slice(0, k);\n      const minSum = sumBy(firstKPrices, 'last');\n\n      // Since prices are sorted, this sum is the minimum sum possible\n      // if the minimum sum is bigger than what we can allocate, no need to continue\n      if (minSum > capacity) {\n        break;\n      }\n\n      const combinations = getCombinations(orderedPrices, k);\n\n      for (const combination of combinations) {\n        const combinationSum = sumBy(combination, 'last');\n\n        if (combinationSum > capacity || combinationSum <= bestSum) {\n          continue;\n        }\n\n        bestSum = combinationSum;\n        bestCombination = combination;\n      }\n    }\n\n    const remainingCash = Number(new BigNumber(capacity).minus(bestSum));\n    return { bestCombination, remainingCash };\n  }\n\n  private async getDailyReturns(\n    portfolioId: string,\n    timeSpanTicks: number,\n    numberOfHops: number,\n  ) {\n    const response = await this.marketPriceModel.getMonteCarloSimulation({\n      portfolioId,\n      timeSpanTicks,\n      numberOfHops,\n    });\n    return response && response.returns;\n  }\n\n  private getTicks(timeSpan: Duration, numberOfDataPoints: number) {\n    // Calculate ticks of C# from JavaScript.\n    // There are 10,000 ticks in a millisecond.\n    // So, we can remove it if we migrate the montecarlo API to Node.js.\n    // https://docs.microsoft.com/en-us/dotnet/api/system.datetime.ticks?view=netframework-4.8#remarks\n    return Math.floor((timeSpan.valueOf() * 10000) / (numberOfDataPoints - 1));\n  }\n\n  private getFutureValues(\n    futureDailyReturnsPerPercentile: number[][],\n    lumpSumAmount: number,\n    addedContribution: number,\n  ) {\n    const futureMarketValuesPerSimulation = [];\n    for (const futureDailyReturns of futureDailyReturnsPerPercentile) {\n      let previousMarketValue = lumpSumAmount;\n      const futureMarketValues = [];\n      for (const futureDailyReturn of futureDailyReturns) {\n        futureMarketValues.push(previousMarketValue);\n        previousMarketValue += addedContribution;\n        previousMarketValue *= 1 + futureDailyReturn;\n      }\n      futureMarketValuesPerSimulation.push(futureMarketValues);\n    }\n\n    return futureMarketValuesPerSimulation;\n  }\n\n  private async checkGoalInput(\n    lumpSumAmount: number,\n    recurringAmount: number,\n    portfolioId: string,\n    startingDate: DateTime,\n    timeHorizon?: DateTime,\n    percentiles?: number[],\n    targetAmount?: number,\n  ) {\n    if (lumpSumAmount < 0) {\n      throw new Error(\"lumpSumAmount can't be less than 0.\");\n    }\n    if (recurringAmount < 0) {\n      throw new Error(\"recurringAmount can't be less than 0.\");\n    }\n    if (!portfolioId) {\n      throw new Error('portfolioId is missing.');\n    }\n    if (\n      portfolioId &&\n      !(await this.sharedModel.aiPortfolios.getAllowedPortfolioIds()).includes(\n        portfolioId,\n      )\n    ) {\n      throw new Error('portfolioId is invalid.');\n    }\n    if (timeHorizon && timeHorizon <= startingDate) {\n      throw new Error(\"Time horizon can't be before the starting date.\");\n    }\n    if (!timeHorizon && !targetAmount && !percentiles) {\n      throw new Error(\n        'targetAmount need to have a value if timeHorizon is null.',\n      );\n    }\n    if (percentiles && (percentiles.length === 0 || percentiles.length > 10)) {\n      throw new Error('percentiles are invalid.');\n    }\n    if (targetAmount && targetAmount < 0) {\n      throw new Error(\"targetAmount can't be less than 0.\");\n    }\n  }\n\n  /**\n   * Calculates cash flow rebalancing orders to make for an account. Takes the\n   * cash the account has and returns BUY orders with the intention of getting\n   * the portfolio closer to the model portfolio in terms of allocation.\n   */\n  private getCashFlowRebalancingOrders(\n    portfolio: ModelPortfolio,\n    cash: number,\n    stockHoldings: Holding[],\n    quotes: Quote[],\n    contribution?: number,\n  ): AutoInvestmentOrderRequest[] {\n    const availableCash = new BigNumber(cash)\n      .plus(contribution || 0)\n      .toNumber();\n\n    const currentMarketValue =\n      sumBy(\n        stockHoldings,\n        'marketValue',\n        AutoInvestmentCalculationModel.AMOUNT_DECIMALS,\n        0,\n      ) || 0;\n\n    // - Based on the account's value (cash + market value of stocks), calculate\n    //   the ideal weight and value of each holding from the model portfolio.\n    // - Based on the account's current holdings, calculate how far away from\n    //   the target market value the account is\n    const targetHoldings = portfolio.holdings.map((holding) => {\n      const currentHolding = stockHoldings.find(\n        (h) => h.symbol === holding.allocationId,\n      );\n      const targetMarketValue = new BigNumber(currentMarketValue)\n        .plus(availableCash)\n        .times(holding.weight)\n        .dp(\n          AutoInvestmentCalculationModel.AMOUNT_DECIMALS,\n          BigNumber.ROUND_DOWN,\n        )\n        .toNumber();\n      const currentMarketValueDiff =\n        targetMarketValue - (currentHolding?.marketValue || 0);\n      return {\n        symbol: holding.allocationId,\n        currentPrice: quotes.find((q) => q.symbol === holding.allocationId)\n          .last,\n        currentQuantity: currentHolding?.quantity || 0,\n        targetWeight: holding.weight,\n        targetMarketValue,\n        currentMarketValueDiff:\n          currentMarketValueDiff > 0 ? currentMarketValueDiff : 0,\n      };\n    });\n\n    // Total amount to buy to get each holding to the perfect weight, regardless\n    // of how much cash you're spending\n    const totalAmountToMeetIdealWeight = targetHoldings.reduce((acc, t) => {\n      return (acc += t.currentMarketValueDiff);\n    }, 0);\n\n    const orders: AutoInvestmentOrderRequest[] = targetHoldings.map((t) => {\n      // Take the amount you need to spend to get the holding to the perfect\n      // weight and calculate it as a %. Take that % and apply it to the actual\n      // amount of cash you have available to use.\n      const totalPrice =\n        t.currentMarketValueDiff <= 0\n          ? 0\n          : new BigNumber(t.currentMarketValueDiff)\n              .div(totalAmountToMeetIdealWeight)\n              .times(availableCash)\n              .dp(2, BigNumber.ROUND_DOWN)\n              .toNumber();\n\n      // Arbitrary number as we will BUY using amount, but for reference this is\n      // the quantity and new market value of the holding after the order\n      const quantity =\n        totalPrice <= 0\n          ? 0\n          : new BigNumber(totalPrice)\n              .div(t.currentPrice)\n              .dp(\n                AutoInvestmentCalculationModel.FRACTIONAL_QUANTITY_DECIMALS,\n                BigNumber.ROUND_DOWN,\n              )\n              .toNumber();\n\n      return {\n        symbol: t.symbol,\n        totalPrice,\n        unitPrice: t.currentPrice,\n        quantity,\n        orderSide: 'buy',\n      };\n    });\n\n    return orders.filter((o) => o.totalPrice > 0);\n  }\n}\n```\n\nis there any actual transactions being made here ?\n\nNo, the code provided does not actually execute any real financial transactions. Instead, it is a backend model that performs calculations and simulations related to auto-investment strategies. The purpose of this code is to generate recommendations, simulate portfolio performance, and calculate ideal orders for rebalancing or investing based on the user's inputs and portfolio data.\n\n### Key Points:\n1. **Simulations and Calculations**:\n   - The code performs **Monte Carlo simulations** to estimate future portfolio performance.\n   - It calculates **ideal holdings** and **rebalancing orders** based on the user's portfolio, cash, and investment goals.\n\n2. **Order Generation**:\n   - The code generates **buy** or **sell orders** (`AutoInvestmentOrderRequest`) based on the calculated ideal portfolio weights and available cash.\n   - These orders are returned as part of the response payload but are not executed.\n\n3. **No Real Transactions**:\n   - The code does not interact with any external systems (e.g., brokerage APIs) to execute the generated orders.\n   - It only provides recommendations or simulated results for the client application to display to the user.\n\n4. **Purpose**:\n   - The primary purpose of this code is to assist users in achieving their investment goals by providing insights and recommendations.\n   - For example, it calculates:\n     - **Target amounts** for a given time horizon.\n     - **Time horizons** for a given target amount.\n     - **Rebalancing orders** to align the portfolio with the model portfolio.\n\n5. **Transaction Data**:\n   - The code fetches historical transaction data (e.g., `getBosTransactions`, `getGtsTransactions`) to calculate the user's current holdings.\n   - However, this is used only for analysis and calculations, not for executing new transactions.\n\n### Example of Non-Execution:\nIn the `getAutoInvestmentOrders` method:\n- The code calculates the ideal orders to rebalance the portfolio.\n- These orders are returned in the response payload:\n  ```ts\n  return {\n    orders,\n    remainingCash,\n    newHoldings,\n    oldHoldings,\n  };\n  ```\n- However, there is no code that sends these orders to a brokerage or trading platform for execution.\n\n### Conclusion:\nThis code is purely for **calculation, simulation, and recommendation purposes**. Any actual transactions would need to be executed by a separate system or service that interacts with a brokerage or trading platform.\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":51}}},{"id":{"replica_id":0,"value":22},"start":39611,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":49}}},{"id":{"replica_id":0,"value":23},"start":42043,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":50}}}],"summary":"Auto-Investment Calculation Logic Analysis","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null},{"range":{"start":3,"end":39558},"icon":"File","label":"back-end/src/models_hk/auto-investment/auto-investment-calculation.ts","metadata":{"path":"back-end/src/models_hk/auto-investment/auto-investment-calculation.ts"}}],"thought_process_output_sections":[]}